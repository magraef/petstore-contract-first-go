// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

const createPet = `-- name: CreatePet :one
WITH inserted_category AS (
    INSERT INTO categories (name)
    VALUES ($2)
    ON CONFLICT (name) DO UPDATE
    SET name = excluded.name
    RETURNING id, name
)
INSERT INTO pets (name, category_id)
SELECT $1, (SELECT id FROM inserted_category)
RETURNING pets.id AS pet_id, pets.name AS pet_name,
    pets.category_id AS category_id, (SELECT name FROM inserted_category) as category_name
`

type CreatePetParams struct {
	Name         string
	Categoryname string
}

type CreatePetRow struct {
	PetID        int32
	PetName      string
	CategoryID   int64
	CategoryName string
}

// Insert a new pet with an existing or new category
// @name - Name of the pet
// @categoryName - Name of the category
// @categoryId - ID of an existing category (optional)
func (q *Queries) CreatePet(ctx context.Context, db DBTX, arg CreatePetParams) (CreatePetRow, error) {
	row := db.QueryRow(ctx, createPet, arg.Name, arg.Categoryname)
	var i CreatePetRow
	err := row.Scan(
		&i.PetID,
		&i.PetName,
		&i.CategoryID,
		&i.CategoryName,
	)
	return i, err
}

const deletePet = `-- name: DeletePet :execresult
DELETE FROM pets WHERE id = $1
`

// Delete a pet by ID
// :id - ID of the pet to delete
func (q *Queries) DeletePet(ctx context.Context, db DBTX, id int32) (pgconn.CommandTag, error) {
	return db.Exec(ctx, deletePet, id)
}

const findAllPets = `-- name: FindAllPets :many
SELECT p.id, p.name, c.id AS category_id, c.name AS category_name
FROM pets p
JOIN categories c ON p.category_id = c.id
WHERE
    CASE
        WHEN $1::varchar[] IS NOT NULL AND array_length($1::varchar[], 1) > 0  THEN
            c.name = ANY($1::varchar[])
        ELSE
            TRUE
    END
    AND p.id > $2
ORDER BY p.id ASC
LIMIT $3
`

type FindAllPetsParams struct {
	CategorieNames []string
	Startfrom      int32
	Maxlimit       int32
}

type FindAllPetsRow struct {
	ID           int32
	Name         string
	CategoryID   int32
	CategoryName string
}

// Find all pets optionally filtered by category.name
// :categorieNames - Optional filter by category.name
// :limit - Limit the number of results
// :from - from which id to collect the results
func (q *Queries) FindAllPets(ctx context.Context, db DBTX, arg FindAllPetsParams) ([]FindAllPetsRow, error) {
	rows, err := db.Query(ctx, findAllPets, arg.CategorieNames, arg.Startfrom, arg.Maxlimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllPetsRow
	for rows.Next() {
		var i FindAllPetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPetById = `-- name: GetPetById :one
SELECT p.id, p.name, c.id AS category_id, c.name AS category_name
FROM pets p
JOIN categories c ON p.category_id = c.id
WHERE p.id = $1
`

type GetPetByIdRow struct {
	ID           int32
	Name         string
	CategoryID   int32
	CategoryName string
}

// Get a pet by ID
// :id - ID of the pet
func (q *Queries) GetPetById(ctx context.Context, db DBTX, id int32) (GetPetByIdRow, error) {
	row := db.QueryRow(ctx, getPetById, id)
	var i GetPetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CategoryID,
		&i.CategoryName,
	)
	return i, err
}

const updatePet = `-- name: UpdatePet :execresult
WITH updated_category AS (
    INSERT INTO categories (name)
    VALUES ($3)
    ON CONFLICT (name) DO UPDATE
    SET name = excluded.name -- Ensure consistent category name
    RETURNING id, name
)
UPDATE pets
SET
    name = COALESCE($1, name),
    category_id = (SELECT id FROM updated_category)
WHERE pets.id = $2
    RETURNING id, name, category_id, (SELECT name FROM updated_category) as category_name
`

type UpdatePetParams struct {
	Name         string
	Petid        int32
	Categoryname string
}

// Update an existing pet by ID
// :id - ID of the pet to update
// :name - New name of the pet
// :category_name - New category ID of the pet
func (q *Queries) UpdatePet(ctx context.Context, db DBTX, arg UpdatePetParams) (pgconn.CommandTag, error) {
	return db.Exec(ctx, updatePet, arg.Name, arg.Petid, arg.Categoryname)
}
